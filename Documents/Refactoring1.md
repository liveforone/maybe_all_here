## 0. 리팩토링 v1.0 소개
* 리팩토링은 좋은 아이디어, 스타일 등 다양한 것이 트리거가 되어 리팩토링을 한다.
* MSA의 경유 자유도가 상당히 높고, 높은 응집성을 추구하기 때문에 다양한 리팩토링 요소가 있다.
* 다만 크기가 커서(모놀리틱에 비해) 리팩토링이 상당히 힘들다.
* 이번 리팩토링에서는 "도메인 모델 패턴", "비동기" 가 주요 요소이다.

## 1. 비동기
### 비동기 소개
* async 디렉토리에는 비동기 설정에 대한 내용이 담겨있다.
* 사용을 원하는 코드에 @Async(사용을 원하는 비동기 빈 이름)을 달아 사용하면 된다.
* 비동기를 사용하는 요소들은 주로 Command, 즉 명령을 처리하는 요소들이다.
* 주로 create, update, delete가 있다.
### 주의 사항
* 비동기를 사용할땐 주의해야하는데, 이번 리팩토링에서는 오로지 command에만 비동기를 적용했기에 command에서 비동기 사용에 관한 주의 사항만 다룬다.
* 1. 일단 리턴값이 존재해선 안된다. 반드시 리턴형이 void인 함수만 사용한다.
* 2. 리턴형이 void라면 두번째로 순서를 파악해야한다.
* 순서가 있는 함수들이 있다. 일례로 파일과 상품이 다대 일 연관관계가 맺어져있고, 이때 상품을 삭제하면서 파일을 원한다면?
* 이 경우에는 파일을 먼저 삭제하고, 상품을 삭제해야 파일이 정상적으로 삭제된다.
* 이런 경우에는 반드시 파일을 먼저 삭제해야하므로 비동기를 적용하면 안된다.
* 이처럼 순서가 영향을 미치는 함수의 경우에는 비동기를 적용해선 안된다.

## 2. 도메인 모델 패턴과 더티 체킹
* 도메인 모델 패턴과 더티체킹은 같이 가는 동반자다.
* 도메인 모델 패턴을 적용하면 서비스로직이 선언형 스타일처럼 깔끔해지고, 로직파악이 쉬워진다.
* 주로 로직을 파악할때 살펴보는 컨트롤러와 서비스를 깔끔하게 두고, 엔티티에 비즈니스로직을 구현한 후 서비스에서 이를 호출하는 식으로 풀어나갔다.
* 이때 업데이트 쿼리를 모두 없애고, 이를 더티체킹으로 깔끔하게 만들었다.
* 이로써 리파지토리와 쿼리는 오로지 '조회'에 집중하여, 얇은 CQRS를 적용할 수 있게된다.
* 엔티티를 항상 조회해야 하는 성능 부담이 있을 수 있는데,
* 사실 PK 기반의 데이터 단건 조회이기 때문에 전체 성능에 거의 영향을 미치지 않는다.
### 주의 사항
* 더하고 빼는 연산에 주의해야한다.
* 계산연산의 경우 계산을 잘 작성하고, 상수를 적극 활용해 가독성을 확보한다.
```
this.object += 값
this.object -= 값
```
### 스타일 가이드 참조
* 스타일 가이드에서도 도메인 모델 패턴의 장점에 대해 설명하며, 프로젝트 적용법에 대해 설명해놓았다.
* [도메인 모델 패턴 - 스타일 가이드](https://github.com/liveforone/study/blob/main/%5B%EB%82%98%EB%A7%8C%EC%9D%98%20%EC%8A%A4%ED%83%80%EC%9D%BC%20%EA%B0%80%EC%9D%B4%EB%93%9C%5D/q.%20%EB%8F%84%EB%A9%94%EC%9D%B8%20%EB%AA%A8%EB%8D%B8%20%ED%8C%A8%ED%84%B4(%EB%8D%94%ED%8B%B0%EC%B2%B4%ED%82%B9).md)

## 3. 리스트나 페이징으로 다량데이터 조회시 dto 프로젝션 사용
* 컴퓨터는 암달의 법칙에서도 알 수 있듯이 결국 가장 공통되는, 가장 많이 일을 하는 부분의 리소스를 줄이는 것이 곧 성능으로 이어진다.
* 가장 많은 부하를 가져다 주는 것은 다름아닌, 다량의 데이터를 조회하는 부분이다.
* 업데이트와 같은 쓰기보단 읽기 쿼리가 더욱 많은데, 그 중에서도 다량의 데이터를 조회하는 쿼리는 상당히 빈번히 요청된다.
* 이 경우 엔티티로 가져와서 mapper를 이용해 dto로 변환시켜 리턴하기보다는,
* 아예 가져올때부터 dto로 가져오는 dto 프로젝션을 이용하면 성능을 올릴 수 있다.
* 띠리서 다량의 데이터조회 쿼리, 즉 list나 페이징 시에 dto 프로젝션을 사용하도록 하였다.
* 쿼리 dsl에서 지원하는 Projections.constructor() 사용하면된다.
* msa 특성상 조인을 할일이 거의 없으나, 간혹 테이블이 두개 이상인 경우가 있다.
* 이때 주의 할 점은, dto 프로젝션에서 페치조인을 사용하면 안된다.
```
 return queryFactory
    .select(Projections.constructor(ReviewResponse.class,
        review.id,
        review.email,
        review.orderId,
        review.content,
        review.recommend,
        review.createdDate)
        )
    .from(review)
    .where(
            review.itemId.eq(itemId),
            ltReviewId(lastId)
    )
    .orderBy(review.id.desc())
    .limit(pageSize)
    .fetch();
```